#+PROPERTY: header-args:ipython :session ipysf :exports both
* Structure function of MUSE velocity maps
+ [2016-10-07 Fri] This will be a re-implementation of my old =strucfunc3.f90=, targeted towards calculating the 2D second-order structure function on the plane of hte sky of the mean velocity from the MUSE orion cubes
+ I will try implementations in
  1. python/numpy
  2. cython
  3. julia
+ And see which is most efficient
  + Trying parallel algorithms too

** Application to the mean velocity maps
*** 

** Different implementations of the structure function
:PROPERTIES:
:header-args: :tangle strucfunc.py
:END:

*** Imports 
#+BEGIN_SRC python
  import numpy as np
  import numba
#+END_SRC


*** Numpy histogram version
#+BEGIN_SRC python
  def strucfunc_numpy(vmap, dlogr=0.15, wmap=None, wmin_factor=1e-3):
      """Calculate structure function by numpy.histogram"""
      ny, nx = vmap.shape
      if wmap is None:
          wmap = np.ones_like(vmap)
      wmin = wmin_factor*np.nanmax(wmap)
      maxr = np.hypot(nx, ny)
      nr = int(np.log10(maxr)/dlogr)
      logr = np.arange(nr)*dlogr
      sf = np.zeros_like(logr)
      nsf = np.zeros_like(logr).astype(int)
      wsf = np.zeros_like(logr)
      weight = np.zeros_like(logr)

      # histogram requires an array that is longer by one
      edges = np.arange(nr+1)*dlogr

      # 2D arrays of x and y coordinates
      ii = np.arange(nx)[None, :]
      jj = np.arange(ny)[:, None]
      for j in range(ny):
          for i in range(nx):
              # everything is a 2D array over the map
              r = np.hypot(ii - i, jj - j)
              dvsq = (vmap - vmap[j, i])**2
              w = wmap[j, i]*wmap
              rmask = (r >= 1.0) & (r <= maxr)
              wmask = wmap > wmin
              if wmap[j, i] > wmin:
                  mask = wmask & rmask
                  # Histogram weighted by dvsq gives sum of dv^2
                  hist, _ = np.histogram(np.log10(r[mask]), bins=edges,
                                         weights=dvsq[mask])
                  sf += hist
                  # Unweighted histogram gives number of points in each bin
                  hist, _ = np.histogram(np.log10(r[mask]), bins=edges)
                  nsf += hist
              hist, _ = np.histogram(np.log10(r[rmask]), bins=edges,
                                     weights=dvsq[rmask]*w[rmask])
              wsf += hist
              hist, _ = np.histogram(np.log10(r[rmask]), bins=edges,
                                     weights=w[rmask])
              weight += hist
                  
      return {'log10 r': logr,
              'Sum dv^2': sf,
              'Sum weights': weight,
              'Sum w * dv^2': wsf,
              'N pairs': nsf,
              'Unweighted B(r)': sf/nsf,
              'Weighted B(r)': wsf/weight}
#+END_SRC


*** New auto-parallelizable numba version
+ [2021-01-26 Tue] Return to this project
+ This one is simple because we are just going to parallelize on the outer loop
+ The only difference over the single-threaded version is that we make 2D arrays to store partial sums as a function of j, then add them all up at the end
+ This allows us to use ~numba.prange~ on the j-loop
+ The result is ~_strucfunc_numba_parallel()~
+ I tried another, arguably even simpler approach in ~_strucfunc_numba_prange()~, but it doesn't work - the jit compiler crashes
#+BEGIN_SRC python
  def strucfunc_numba_parallel(vmap, dlogr=0.15, wmap=None, wmin_factor=1e-3):
      """Calculate structure function via naive python algorithm"""
      ny, nx = vmap.shape
      if wmap is None:
          wmap = np.ones((ny, nx))
      wmin = wmin_factor*np.nanmax(wmap)
      maxr = np.hypot(nx, ny)
      nr = int(np.log10(maxr)/dlogr)
      logr = np.arange(nr)*dlogr
      sf = np.zeros((nr,))
      nsf = np.zeros((nr,), dtype=np.int64)
      wsf = np.zeros((nr,))
      weight = np.zeros((nr,))
      sf, weight, wsf, nsf = _strucfunc_numba_parallel(
          ny, nx, nr,
          vmap, wmap,
          wmin, dlogr, maxr,
          sf, weight, wsf, nsf
      )
      return {'log10 r': logr,
              'Sum dv^2': sf,
              'Sum weights': weight,
              'Sum w * dv^2': wsf,
              'N pairs': nsf,
              'Unweighted B(r)': sf/nsf,
              'Weighted B(r)': wsf/weight}


  @numba.jit(nopython=True, parallel=True)
  def _strucfunc_numba_prange(
          ny, nx, nr,
          vmap, wmap,
          wmin, dlogr, maxr,
          sf, weight, wsf, nsf
  ):
      # THIS ONE DOES NOT WORK !!!!!!
      # Parallel loop on the outer axis
      for j in numba.prange(ny):
          # make per-thread containers to hold partial sums
          _sf = np.zeros(nr)
          _weight = np.zeros(nr)
          _wsf = np.zeros(nr)
          _nsf = np.zeros(nr, dtype=np.int64)
          for i in range(nx):
              for jj in range(ny):
                  for ii in range(i+1, nx):
                      r = np.hypot(ii - i, jj - j)
                      ir = int(np.log10(r)/dlogr)
                      if 0 <= ir < nr:
                          dvsq = (vmap[jj, ii] - vmap[j, i])**2
                          if (wmap[j, i] > wmin) and (wmap[jj, ii] > wmin):
                              _sf[ir] += dvsq
                              _nsf[ir] += 1
                          w = wmap[j, i]*wmap[jj, ii]
                          _wsf[ir] += w*dvsq
                          _weight[ir] += w
          # Now add the partial sums into the global sums
          sf += _sf
          weight += _weight
          wsf += _wsf
          nsf += _nsf
      return sf, weight, wsf, nsf


  @numba.jit(nopython=True, parallel=True)
  def _strucfunc_numba_parallel(
          ny, nx, nr,
          vmap, wmap,
          wmin, dlogr, maxr,
          sf, weight, wsf, nsf
  ):
      # Use per-j containers to hold partial results 
      _sf = np.zeros((ny, nr))
      _weight = np.zeros((ny, nr))
      _wsf = np.zeros((ny, nr))
      _nsf = np.zeros((ny, nr), dtype=np.int64)
      for j in numba.prange(ny):
          for i in range(nx):
              for jj in range(ny):
                  for ii in range(i+1, nx):
                      r = np.hypot(ii - i, jj - j)
                      ir = int(np.log10(r)/dlogr)
                      if 0 <= ir < nr:
                          dvsq = (vmap[jj, ii] - vmap[j, i])**2
                          if (wmap[j, i] > wmin) and (wmap[jj, ii] > wmin):
                              _sf[j, ir] += dvsq
                              _nsf[j, ir] += 1
                          w = wmap[j, i]*wmap[jj, ii]
                          _wsf[j, ir] += w*dvsq
                          _weight[j, ir] += w
      sf = np.sum(_sf, axis=0)
      weight = np.sum(_weight, axis=0)
      wsf = np.sum(_wsf, axis=0)
      nsf = np.sum(_nsf, axis=0)
      return sf, weight, wsf, nsf
#+END_SRC

*** Parallelizable numba accelerated version
+ [2021-01-26 Tue] *OLD VERSION THAT NO LONGER WORKS*
  + Now removed from tangled file
+ We give the option to chunk on the first dimension, so that we can parcel it out among threads
+ This is a bit more complex than the example in the docs, since the result arrays don't get chunked, but are the accumulated sum of the results from each thread
  + So we need per-thread copies of them 
#+BEGIN_SRC python :tangle no
  from concurrent import futures

  def strucfunc_numba_futures(vmap, dlogr=0.15,
                              wmap=None, wmin_factor=1e-3, numthreads=4):
      """Calculate structure function via jitted, threaded python algorithm"""
      ny, nx = vmap.shape
      if wmap is None:
          wmap = np.ones((ny, nx))
      wmin = wmin_factor*np.nanmax(wmap)
      maxr = np.hypot(nx, ny)
      nr = int(np.log10(maxr)/dlogr)
      logr = np.arange(nr)*dlogr

      # arrays to hold the total accumulation sums
      sf = np.zeros_like(logr)
      nsf = np.zeros_like(logr).astype(int)
      wsf = np.zeros_like(logr)
      weight = np.zeros_like(logr)

      @numba.jit(nogil=True, nopython=True)
      def _strucfunc_chunk(j1, j2):
          """Pure python function designed to be jitted and threaded.

          Finds partial contribution to structure function from a chunk
          (vmap[j1:j2, :] - vmap[:, :])^2
          """
          # Per-thread arrays of partial accumulation sums
          _sf = np.zeros(nr)
          _nsf = np.zeros(nr, dtype=np.int64)
          _wsf = np.zeros(nr)
          _weight = np.zeros(nr)
          # outer loop is over only those rows that are in chunk 
          for j in range(j1, j2):
              for i in range(nx):
                  for jj in range(ny):
                      for ii in range(i+1, nx):
                          r = np.hypot(ii - i, jj - j)
                          ir = int(np.log10(r)/dlogr)
                          if 0 <= ir < nr:
                              dvsq = (vmap[jj, ii] - vmap[j, i])**2
                              if (wmap[j, i] > wmin) and (wmap[jj, ii] > wmin):
                                  _sf[ir] += dvsq
                                  _nsf[ir] += 1.0
                              w = 1.0 # wmap[j, i]*wmap[jj, ii]
                              _wsf[ir] = _wsf[ir] + w*dvsq
                              _weight[ir] = _weight[ir] + w
          # return the partial accumulated sums for this chunk
          return _sf, _nsf, _wsf, _weight

      # Do integer division with remainder
      chunklen, extras = divmod(ny, numthreads)
      # So "normal" chunks have length chunklen
      # While the first `extras` chunks have length (chunklen  + 1)
      long_chunks = [[i*(chunklen + 1), (i+1)*(chunklen + 1)]
                     for i in range(extras)]
      i0 = extras*(chunklen + 1)
      normal_chunks = [[i*chunklen + i0, (i+1)*chunklen + i0]
                       for i in range(chunklen - extras)]
      chunklimits = long_chunks + normal_chunks

      # Spawn one thread per chunk
      with futures.ThreadPoolExecutor(max_workers=numthreads) as ex:
          chunks = [
              ex.submit(_strucfunc_chunk, j1, j2)
              for j1, j2 in chunklimits
          ]
          for f in futures.as_completed(chunks):
              # As each thread finishes, add its partial result into the
              # arrays
              _sf, _nsf, _wsf, _weight = f.result()
              sf += np.array(_sf)
              nsf += np.array(_nsf)
              wsf += np.array(_wsf)
              weight += np.array(_weight)

      return {'log10 r': logr,
              'Sum dv^2': sf,
              'Sum weights': weight,
              'Sum w * dv^2': wsf,
              'N pairs': nsf,
              'Unweighted B(r)': sf/nsf,
              'Weighted B(r)': wsf/weight}

#+END_SRC

*** Numba accelerated version
#+BEGIN_SRC python
  def strucfunc_numba(vmap, dlogr=0.15, wmap=None, wmin_factor=1e-3):
      """Calculate structure function via naive python algorithm"""
      ny, nx = vmap.shape
      if wmap is None:
          wmap = np.ones((ny, nx))
      wmin = wmin_factor*np.nanmax(wmap)
      maxr = np.hypot(nx, ny)
      nr = int(np.log10(maxr)/dlogr)
      logr = np.arange(nr)*dlogr
      sf = np.zeros((nr,))
      nsf = np.zeros((nr,), dtype=np.int64)
      wsf = np.zeros((nr,))
      weight = np.zeros((nr,))
      sf, weight, wsf, nsf = _strucfunc_numba(
          ny, nx, nr,
          vmap, wmap,
          wmin, dlogr, maxr,
          sf, weight, wsf, nsf
      )
      return {'log10 r': logr,
              'Sum dv^2': sf,
              'Sum weights': weight,
              'Sum w * dv^2': wsf,
              'N pairs': nsf,
              'Unweighted B(r)': sf/nsf,
              'Weighted B(r)': wsf/weight}

  @numba.jit(nopython=True)
  def _strucfunc_numba(
          ny, nx, nr,
          vmap, wmap,
          wmin, dlogr, maxr,
          sf, weight, wsf, nsf
  ):
      for j in range(ny):
          for i in range(nx):
              for jj in range(ny):
                  for ii in range(i+1, nx):
                      r = np.hypot(ii - i, jj - j)
                      ir = int(np.log10(r)/dlogr)
                      if 0 <= ir < nr:
                          dvsq = (vmap[jj, ii] - vmap[j, i])**2
                          if (wmap[j, i] > wmin) and (wmap[jj, ii] > wmin):
                              sf[ir] += dvsq
                              nsf[ir] += 1
                          w = wmap[j, i]*wmap[jj, ii]
                          wsf[ir] += w*dvsq
                          weight[ir] += w
      return sf, weight, wsf, nsf
#+END_SRC
*** Naive python function

#+BEGIN_SRC python
  def strucfunc_python(vmap, dlogr=0.15, wmap=None, wmin_factor=1e-3):
      """Calculate structure function via naive python algorithm"""
      ny, nx = vmap.shape
      if wmap is None:
          wmap = np.ones_like(vmap)
      wmin = wmin_factor*np.nanmax(wmap)
      maxr = np.hypot(nx, ny)
      nr = int(np.log10(maxr)/dlogr)
      logr = np.arange(nr)*dlogr
      sf = np.zeros_like(logr)
      nsf = np.zeros_like(logr).astype(int)
      wsf = np.zeros_like(logr)
      weight = np.zeros_like(logr)

      for j in range(ny):
          for i in range(nx):
              for jj in range(ny):
                  for ii in range(i+1, nx):
                      r = np.hypot(ii - i, jj - j)
                      ir = int(np.log10(r)/dlogr)
                      if 0 <= ir < nr:
                          dvsq = (vmap[jj, ii] - vmap[j, i])**2
                          if (wmap[j, i] > wmin) and (wmap[jj, ii] > wmin):
                              sf[ir] += dvsq
                              nsf[ir] += 1
                          w = wmap[j, i]*wmap[jj, ii]
                          wsf[ir] += w*dvsq
                          weight[ir] += w
                  
      return {'log10 r': logr,
              'Sum dv^2': sf,
              'Sum weights': weight,
              'Sum w * dv^2': wsf,
              'N pairs': nsf,
              'Unweighted B(r)': sf/nsf,
              'Weighted B(r)': wsf/weight}
#+END_SRC

*** A function to test the structure functions
#+BEGIN_SRC ipython :results silent
  def test_strucfunc(n=50, func=strucfunc_python, **kwds):
      """Set up arrays for stucture function and run it"""
      ny, nx = n, n
      vels = np.random.normal(size=(ny, nx))
      bright = np.ones((ny, nx))
      rslt = func(vmap=vels, wmap=bright, **kwds)
      return ['{} :: {}'.format(k, list(v)) for (k, v) in rslt.items()]
#+END_SRC


** New 2021 tests of the structure function routines
+ [2021-01-15 Fri] Time to see if this machinery still works
+ Re-write the tests in normal python blocks instead of ipython
  + I moved the ~test_strucfunc()~ function to the ~strucfunc.py~ library
+ Use the numba single-threaded version



  
*** Speed tests on gris (2019 MBP laptop)
#+begin_src ipython :results output verbatim
  import numpy as np
  import strucfunc

  funcs = [
      strucfunc.strucfunc_numpy,
      strucfunc.strucfunc_numba,
      strucfunc.strucfunc_numba_parallel
  ]

  for func in funcs:
      %timeit -r 3 strucfunc.test_strucfunc(n=50, func=func)
#+end_src

#+RESULTS:
: 1.76 s ± 42.8 ms per loop (mean ± std. dev. of 3 runs, 1 loop each)
: 56.9 ms ± 3.02 ms per loop (mean ± std. dev. of 3 runs, 1 loop each)
: 10 ms ± 552 µs per loop (mean ± std. dev. of 3 runs, 1 loop each)

#+begin_src ipython :results output verbatim
  for func in funcs:
      %timeit -r 3 strucfunc.test_strucfunc(n=100, func=func)
#+end_src

#+RESULTS:
: 24.4 s ± 248 ms per loop (mean ± std. dev. of 3 runs, 1 loop each)
: 862 ms ± 3.56 ms per loop (mean ± std. dev. of 3 runs, 1 loop each)
: 126 ms ± 9.91 ms per loop (mean ± std. dev. of 3 runs, 10 loops each)

|   N | Numpy | Numba | Parallel  N=8 |
|-----+-------+-------+---------------|
|  50 |  1.76 | 0.057 |         0.010 |
| 100 |  24.4 | 0.862 |         0.126 |
| 200 |       |  14.9 |          1.75 |
| 400 |       |       |          27.2 |

Conclusions:
+ We are 25% faster than hypatia for numba single-threaded
+ We are *twice as fast* than hypatia for numba multi-threaded
  
*** Smoke test
#+begin_src python :results list :return data
  import numpy as np
  import strucfunc
  data = strucfunc.test_strucfunc(n=30)
#+end_src

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1790.0835125126453, 3415.568640075873, 8783.048277377673, 18089.579843379666, 36255.21967635025, 63034.21571809936, 118324.11615798164, 175416.08709170678, 224554.23470398423, 150712.4411793686]
- Sum weights[870.0, 1682.0, 4088.0, 8534.0, 17424.0, 30000.0, 56074.0, 83308.0, 108730.0, 75258.0]
- Sum w * dv^2[1790.0835125126453, 3415.568640075873, 8783.048277377673, 18089.579843379666, 36255.21967635025, 63034.21571809936, 118324.11615798164, 175416.08709170678, 224554.23470398423, 150712.4411793686]
- N pairs[870, 1682, 4088, 8534, 17424, 30000, 56074, 83308, 108730, 75258]
- Unweighted B(r)[2.0575672557616613, 2.0306591201402338, 2.148495175483775, 2.119707035783884, 2.0807632963929206, 2.101140523936645, 2.1101422434279993, 2.1056331575803857, 2.065246341432762, 2.0026102365113156]
- Weighted B(r)[2.0575672557616613, 2.0306591201402338, 2.148495175483775, 2.119707035783884, 2.0807632963929206, 2.101140523936645, 2.1101422434279993, 2.1056331575803857, 2.065246341432762, 2.0026102365113156]
  
That seems fine with basic python

#+begin_src python :results list :return data
  import numpy as np
  import strucfunc
  data = strucfunc.test_strucfunc(n=30, func=strucfunc.strucfunc_numpy)
#+end_src

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[6745.7675214546, 6635.61738948819, 19071.12590441111, 35931.20212790118, 73164.4351339741, 121172.62252275746, 226735.84403735911, 332147.86436370236, 433417.0577377365, 307838.3708918644]
- Sum weights[3480.0, 3364.0, 9856.0, 18688.0, 37908.0, 62820.0, 117068.0, 170576.0, 222080.0, 152580.0]
- Sum w * dv^2[6745.7675214546, 6635.61738948819, 19071.12590441111, 35931.20212790118, 73164.4351339741, 121172.62252275746, 226735.84403735911, 332147.86436370236, 433417.0577377365, 307838.3708918644]
- N pairs[3480, 3364, 9856, 18688, 37908, 62820, 117068, 170576, 222080, 152580]
- Unweighted B(r)[1.9384389429467241, 1.972537868456656, 1.934976248418335, 1.9226884700289588, 1.9300526309479291, 1.9288860637178837, 1.9367875426022407, 1.9472133498481754, 1.9516258003320268, 2.017553879223125]
- Weighted B(r)[1.9384389429467241, 1.972537868456656, 1.934976248418335, 1.9226884700289588, 1.9300526309479291, 1.9288860637178837, 1.9367875426022407, 1.9472133498481754, 1.9516258003320268, 2.017553879223125]

That seems fine with numpy

#+begin_src python :results list :return data
  import numpy as np
  import strucfunc
  data = strucfunc.test_strucfunc(n=30, func=strucfunc.strucfunc_numba)
#+end_src

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1769.9861165442956, 3297.9607343152943, 8099.953772341007, 16949.88368572312, 34320.48803173328, 59479.55593832436, 111727.46611738572, 166339.25380655914, 216754.04827395306, 149937.7707534742]
- Sum weights[870.0, 1682.0, 4088.0, 8534.0, 17424.0, 30000.0, 56074.0, 83308.0, 108730.0, 75258.0]
- Sum w * dv^2[1769.9861165442956, 3297.9607343152943, 8099.953772341007, 16949.88368572312, 34320.48803173328, 59479.55593832436, 111727.46611738572, 166339.25380655914, 216754.04827395306, 149937.7707534742]
- N pairs[870, 1682, 4088, 8534, 17424, 30000, 56074, 83308, 108730, 75258]
- Unweighted B(r)[2.0344668006256272, 1.9607376541708053, 1.9813976938211857, 1.9861593257233563, 1.9697249788643985, 1.982651864610812, 1.9925003765985254, 1.9966780358015934, 1.9935072958148905, 1.9923167072400836]
- Weighted B(r)[2.0344668006256272, 1.9607376541708053, 1.9813976938211857, 1.9861593257233563, 1.9697249788643985, 1.982651864610812, 1.9925003765985254, 1.9966780358015934, 1.9935072958148905, 1.9923167072400836]

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1889.5986461794332, 3656.0729756636206, 8541.434707462542, 18540.66666198872, 37853.772168629446, 66446.43220432804, 128192.72984937951, 202798.74212529443, 307794.00925873645, inf]
- Sum weights[870.0, 1711.0, 4174.0, 8842.0, 18357.0, 32565.0, 63527.0, 102224.0, 155960.0, 180969.0]
- Sum w * dv^2[1889.5986461794332, 3656.0729756636206, 8541.434707462542, 18540.66666198872, 37853.772168629446, 66446.43220432804, 128291.02578875441, 204052.37276156078, 312135.83618384565, inf]
- N pairs[870, 1711, 4174, 8842, 18357, 32565, 63462, 101512, 153472, 173440]
- Unweighted B(r)[2.1719524668729115, 2.1368047782955117, 2.0463427665219314, 2.096886073511504, 2.0620892394524946, 2.04042475677347, 2.019991961321413, 1.9977809729420604, 2.0055385298864707, inf]
- Weighted B(r)[2.1719524668729115, 2.1368047782955117, 2.0463427665219314, 2.096886073511504, 2.0620892394524946, 2.04042475677347, 2.0194724414619674, 1.996129800844819, 2.001383920132378, inf]

Not fine with parallel, but never mind

**** Previous parallel results - all bad :(
:PROPERTIES:
:VISIBILITY: folded
:END:

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1723.6683306090197, 3417.081774348257, 8399.654267963559, 17894.93620086622, 35845.27400877609, 61731.04696194707, 114798.37631195819, 173807.59987327253, 233859.84556981444, 183337.3882649628]
- Sum weights[870.0, 1711.0, 4174.0, 8842.0, 18357.0, 32565.0, 63527.0, 102224.0, 155960.0, 180969.0]
- Sum w * dv^2[1723.6683306090197, 3445.7603462212205, 8491.469736101475, 18354.36801599729, 37357.96020260657, 66212.86420180803, 128889.2363632296, 208765.09104259743, 317938.0201712999, inf]
- N pairs[870, 1696, 4116, 8602, 17571, 30290, 56833, 85632, 115643, 91643]
- Unweighted B(r)[1.981227966217264, 2.014788782044963, 2.0407323294372106, 2.0803227389986305, 2.0400247002888903, 2.038000890127008, 2.0199246267478084, 2.0297038475484928, 2.022256821163533, 2.000560744028052]
- Weighted B(r)[1.981227966217264, 2.0138868183642433, 2.03437224151928, 2.0758163329560384, 2.0350798171055495, 2.0332523937297107, 2.0288890765065184, 2.042231677909272, 2.038586946468966, inf]

#+RESULTS:
: 

#+RESULTS:
: 

#+RESULTS:
: 

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1811.0577274424736, 3616.5307387663065, 8375.256601311004, 17997.510605272517, 36871.642245553725, 63858.07349761735, 116168.45720595903, 178334.34255995267, 243619.76432206188, 196837.9786777729]
- Sum weights[870.0, 1711.0, 4174.0, 8842.0, 18357.0, 32565.0, 63527.0, 102224.0, 155960.0, 180969.0]
- Sum w * dv^2[1811.0577274424736, 3660.147409141918, 8526.509829998335, 18531.738811642925, 38537.13701702954, 68777.18451830356, 130799.45805644005, 213192.74738212855, 327351.36279548774, inf]
- N pairs[870, 1696, 4116, 8602, 17571, 30290, 56826, 85585, 115537, 91708]
- Unweighted B(r)[2.0816755487844523, 2.1323884072914545, 2.034804810814141, 2.0922472221893185, 2.0984373254540847, 2.108222961294729, 2.0442835534079298, 2.0837102595075385, 2.1085865508197537, 2.1463555925085367]
- Weighted B(r)[2.0816755487844523, 2.139186095348871, 2.0427670891227443, 2.095876364130618, 2.099315629843087, 2.1119970679657167, 2.058958522461946, 2.0855449540433613, 2.0989443626281594, inf]

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1724.841696710482, 3302.127035166708, 8226.21398980898, 17185.493416780813, 34924.79497295108, 59783.07620919809, 114132.03386288072, 173978.21449947834, 232517.84022202028, 183613.2749661914]
- Sum weights[870.0, 2.50479805015848e+262, 5.00959610031696e+262, 1.25239902507924e+263, 2.755277855174328e+263, 5.510555710348656e+263, -9.216690764486685e+305, nan, nan, nan]
- Sum w * dv^2[1724.841696710482, 1.997544195900679e+263, 5.2147998471186244e+262, 2.185953955835647e+263, 3.701021091402209e+263, 1.1137647624897654e+264, -2.1332600709787475e+306, nan, nan, nan]
- N pairs[870, 1696, 4116, 8602, 17571, 30290, 56870, 85649, 115392, 91472]
- Unweighted B(r)[1.9825766628856114, 1.94700886507471, 1.9985942638019876, 1.9978485720507804, 1.9876384367964874, 1.9736902016902638, 2.0068935091063955, 2.031293003998626, 2.0150256536156776, 2.0073167195009556]
- Weighted B(r)[1.9825766628856114, 7.974871250695413, 1.0409621340108999, 1.745413332382098, 1.343247863169881, 2.021147813455817, 2.3145618373120684, nan, nan, nan]

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1687.6273695540626, 3449.8803000769026, 8402.388260103524, 17409.270813913783, 35683.810648593746, 61368.59662941521, 116482.2803801157, 176100.4101673208, 233250.61026585958, 188667.70389662244]
- Sum weights[870.0, 2.50479805015848e+262, 5.00959610031696e+262, 1.25239902507924e+263, 2.755277855174328e+263, 5.510555710348656e+263, -9.216690764486685e+305, nan, nan, nan]
- Sum w * dv^2[1687.6273695540626, 4.295546234832263e+262, 2.7998055287704347e+263, 1.4461893319767315e+263, 4.4174601575222607e+263, 9.339295612693431e+263, -1.6497368265115835e+306, nan, nan, nan]
- N pairs[870, 1696, 4116, 8602, 17571, 30290, 56870, 85649, 115392, 91493]
- Unweighted B(r)[1.939801574200072, 2.034127535422702, 2.0413965646510017, 2.0238631497225974, 2.030835504444468, 2.0260348837707234, 2.048220157906026, 2.0560708258978018, 2.0213759209118445, 2.062099875363388]
- Weighted B(r)[1.939801574200072, 1.714927171298493, 5.5888847577817495, 1.1547352744747068, 1.6032721161774681, 1.6948010515807903, 1.7899448605439503, nan, nan, nan]

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1875.1915298017695, 3748.4767735719493, 9088.586356376916, 18480.90252406505, 38447.25157737338, 65301.9828064176, 125103.87056832021, 185682.36538400917, 243660.24061355236, 185275.24960663088]
- Sum weights[870.0, 2.50479805015848e+262, 5.00959610031696e+262, 1.25239902507924e+263, 2.755277855174328e+263, 5.510555710348656e+263, -9.216690764486685e+305, nan, nan, nan]
- Sum w * dv^2[1875.1915298017695, 2.4607901985033447e+261, 2.778163889800369e+263, 2.552021047413412e+263, 3.5156911979170853e+263, 1.10494666494471e+264, -1.4544342997585357e+306, nan, nan, nan]
- N pairs[870, 1697, 4118, 8607, 17582, 30309, 56900, 85724, 115543, 91690]
- Unweighted B(r)[2.1553925629905395, 2.2088843686340303, 2.207038940353792, 2.147194437558389, 2.1867393685231136, 2.154540988037138, 2.1986620486523765, 2.166048777285348, 2.108827368283257, 2.0206701887515637]
- Weighted B(r)[2.1553925629905395, 0.09824305789233784, 5.545684390852574, 2.037706031631527, 1.2759842682707023, 2.0051456205581113, 1.5780439388969116, nan, nan, nan]

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1812.7572010086212, 3594.502309480381, 8731.869945796621, 17829.12618570387, 36659.053570832846, 63396.25607028372, 117869.81261173711, 178881.8646542508, 241425.6967513859, 187856.2701096623]
- Sum weights[870.0, 2.50479805015848e+262, 5.00959610031696e+262, 1.25239902507924e+263, 2.755277855174328e+263, 5.510555710348656e+263, -9.216690764486685e+305, nan, nan, nan]
- Sum w * dv^2[1812.7572010086212, 1.2546107225903726e+263, 1.1013491961776596e+263, 2.3792694188504937e+263, 6.203434851545483e+263, 7.913915275341703e+263, -7.04807212523662e+305, nan, nan, nan]
- N pairs[870, 1696, 4116, 8602, 17571, 30290, 56870, 85649, 115403, 91628]
- Unweighted B(r)[2.083628966676576, 2.119399946627583, 2.121445565062347, 2.072672190851415, 2.086338487896696, 2.092976430184342, 2.0726184739183595, 2.0885458633988816, 2.092022709560288, 2.050205942612109]
- Weighted B(r)[2.083628966676576, 5.008829843631476, 2.198479027297184, 1.8997694594180605, 2.251473418514079, 1.4361374226703871, 0.7647074536116495, nan, nan, nan]

#+RESULTS:
: 

#+RESULTS:
: 

#+RESULTS:
: 

#+RESULTS:
: 

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1694.5647794492, 3284.8482738737885, 8125.217623571486, 16969.837632520415, 34760.45292833874, 60459.15468088965, 112020.88321651562, 168512.99425941124, 236125.69010263096, 4.857473810405972e+303]
- Sum weights[870.0, 2.2357232158569665e+243, 5.00959610031696e+262, 2.0038384401267842e+263, 4.5086364902852645e+263, 1.0019192200633911e+264, nan, nan, nan, nan]
- Sum w * dv^2[1694.5647794492, 1.1368003440041894e+242, 1.1217010014551092e+263, 9.07835957394316e+263, 8.364227284325548e+263, 1.6773844067684134e+264, nan, nan, nan, nan]
- N pairs[870, 1695, 4125, 8643, 17664, 30486, 57196, 86343, 117589, 97628]
- Unweighted B(r)[1.9477756085622988, 1.9379635834063649, 1.9697497269264208, 1.9634198348398029, 1.9678698442220752, 1.9831776776516976, 1.9585440103593892, 1.951669437700928, 2.008059343158212, 4.975492492323895e+298]
- Weighted B(r)[1.9477756085622988, 0.05084709663259666, 2.2391046683067692, 4.530484789666359, 1.855156720296237, 1.6741713036129657, nan, nan, nan, nan]

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1993.128134172266, 3471.3950110856376, 8334.69047388174, 17787.515834921116, 37030.49704511756, 63113.87827314918, 118811.25252982903, 178313.4732054548, 240661.95310712451, 186372.3398403697]
- Sum weights[870.0, 2.2357232158569665e+243, 5.00959610031696e+262, 2.0038384401267842e+263, 4.5086364902852645e+263, 1.0019192200633911e+264, nan, nan, nan, nan]
- Sum w * dv^2[1993.128134172266, 1.2604366094824627e+243, 2.1924549660628002e+263, 4.6202165388059516e+263, 8.116472768168653e+263, 1.9301579022971333e+264, nan, nan, nan, nan]
- N pairs[870, 1695, 4125, 8643, 17664, 30486, 57196, 86312, 117512, 93416]
- Unweighted B(r)[2.2909518783589267, 2.048020655507751, 2.0205310239713308, 2.0580256664261385, 2.09638230554334, 2.070257766619077, 2.077265062763638, 2.065917522539795, 2.0479776797869538, 1.995079427939215]
- Weighted B(r)[2.2909518783589267, 0.5637713114676987, 4.376510445471008, 2.3056831560300974, 1.8002056243960174, 1.9264606004613953, nan, nan, nan, nan]

#+RESULTS:
- log10 r[0.0, 0.15, 0.3, 0.44999999999999996, 0.6, 0.75, 0.8999999999999999, 1.05, 1.2, 1.3499999999999999]
- Sum dv^2[1810.4265437049921, 3455.90331373111, 8084.301944851569, 17492.50929254252, 34921.19063745152, 59865.78075810678, 112448.18858158427, 171425.1486733535, 235407.71057083315, 191598.32116093047]
- Sum weights[870.0, 2.2357232158569665e+243, 5.00959610031696e+262, 2.0038384401267842e+263, 4.5086364902852645e+263, 1.0019192200633911e+264, nan, nan, nan, nan]
- Sum w * dv^2[1810.4265437049921, 6.04142375657511e+243, 7.471934155885998e+262, 3.10421470043682e+263, 1.3406116553207489e+264, 1.8077829557553773e+264, nan, nan, nan, nan]
- N pairs[870, 1695, 4125, 8643, 17664, 30486, 57196, 86343, 117561, 93328]
- Unweighted B(r)[2.0809500502356233, 2.0388810110508024, 1.9598307745094712, 2.0238932422240565, 1.9769695786600723, 1.9637138607264575, 1.966014906314852, 1.985397179543837, 2.0024303176294276, 2.052956467093803]
- Weighted B(r)[2.0809500502356233, 2.7022234745902547, 1.4915242678772536, 1.5491342207410763, 2.9734303446493366, 1.804320068479173, nan, nan, nan, nan]

** Testing and timing the structure function routines
:PROPERTIES:
:header-args:ipython: :session ipysf :exports both 
:END:

#+BEGIN_SRC ipython
  import numpy as np
  import strucfunc
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython
from importlib import reload
reload(strucfunc)
#+END_SRC

#+RESULTS:
: <module 'strucfunc' from '/Users/will/Dropbox/muse-strucfunc/strucfunc.py'>

#+BEGIN_SRC ipython :results output
help(strucfunc.strucfunc_numba_futures)
#+END_SRC
#+RESULTS:
: Help on function strucfunc_numba_futures in module strucfunc:
: 
: strucfunc_numba_futures(vmap, dlogr=0.15, wmap=None, wmin_factor=0.001, numthreads=4)
:     Calculate structure function via jitted, threaded python algorithm
: 



*** Basic tests with 30 \times 30 arrays
+ These should all be fast.
+ The structure functions should be around 2.0

#+BEGIN_SRC ipython :results list
  test_strucfunc(n=30)
#+END_SRC

#+RESULTS:
- N pairs :: [870, 1682, 4088, 8534, 17424, 30000, 56074, 83308, 108730, 75258]
- Sum w * dv^2 :: [1734.8915026312045, 3148.4335528064494, 7952.1693603066869, 16387.721480518787, 34075.741796205271, 58219.331151452476, 109742.34724118238, 163359.44041876114, 212378.87817210823, 150278.62640183003]
- Weighted B(r) :: [1.9941281639439132, 1.8718392109431923, 1.9452469080985046, 1.9202860886476198, 1.9556784777436451, 1.9406443717150825, 1.957098606148703, 1.9609094014831845, 1.9532684463543477, 1.9968458689020441]
- log10 r :: [0.0, 0.14999999999999999, 0.29999999999999999, 0.44999999999999996, 0.59999999999999998, 0.75, 0.89999999999999991, 1.05, 1.2, 1.3499999999999999]
- Unweighted B(r) :: [1.9941281639439132, 1.8718392109431923, 1.9452469080985046, 1.9202860886476198, 1.9556784777436451, 1.9406443717150825, 1.957098606148703, 1.9609094014831845, 1.9532684463543477, 1.9968458689020441]
- Sum weights :: [870.0, 1682.0, 4088.0, 8534.0, 17424.0, 30000.0, 56074.0, 83308.0, 108730.0, 75258.0]
- Sum dv^2 :: [1734.8915026312045, 3148.4335528064494, 7952.1693603066869, 16387.721480518787, 34075.741796205271, 58219.331151452476, 109742.34724118238, 163359.44041876114, 212378.87817210823, 150278.62640183003]


#+BEGIN_SRC ipython :results list
  test_strucfunc(n=30, func=strucfunc.strucfunc_numpy)
#+END_SRC

#+RESULTS:
- N pairs :: [3480, 3364, 9856, 18688, 37908, 62820, 117068, 170576, 222080, 152580]
- Sum w * dv^2 :: [7019.0488371258498, 6924.8787174187337, 20668.8908002955, 38960.518370501537, 79441.74862861757, 130615.89437995211, 245004.2475280884, 355836.41141792346, 464107.67915670021, 320575.72488795995]
- Weighted B(r) :: [2.0169680566453589, 2.0585251835370788, 2.0970871347702413, 2.0847880121201592, 2.0956460015990706, 2.079208761221778, 2.0928370479387057, 2.0860872069806038, 2.0898220423122309, 2.1010337192814257]
- log10 r :: [0.0, 0.14999999999999999, 0.29999999999999999, 0.44999999999999996, 0.59999999999999998, 0.75, 0.89999999999999991, 1.05, 1.2, 1.3499999999999999]
- Unweighted B(r) :: [2.0169680566453589, 2.0585251835370788, 2.0970871347702413, 2.0847880121201592, 2.0956460015990706, 2.079208761221778, 2.0928370479387057, 2.0860872069806038, 2.0898220423122309, 2.1010337192814257]
- Sum weights :: [3480.0, 3364.0, 9856.0, 18688.0, 37908.0, 62820.0, 117068.0, 170576.0, 222080.0, 152580.0]
- Sum dv^2 :: [7019.0488371258498, 6924.8787174187337, 20668.8908002955, 38960.518370501537, 79441.74862861757, 130615.89437995211, 245004.2475280884, 355836.41141792346, 464107.67915670021, 320575.72488795995]


#+BEGIN_SRC ipython :results list
  test_strucfunc(n=30, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
- N pairs :: [870, 1682, 4088, 8534, 17424, 30000, 56074, 83308, 108730, 75258]
- Sum w * dv^2 :: [1662.7415110093777, 3250.6701423138593, 8266.7003353701548, 16632.184278265373, 35147.979104501705, 59536.567803899008, 111256.5922657162, 166023.49650123221, 214530.9155747208, 148773.69888176298]
- Weighted B(r) :: [1.9111971390912388, 1.9326219633257189, 2.0221869704917208, 1.9489318348096289, 2.0172164316174075, 1.984552260129967, 1.9841030114797624, 1.9928877959047415, 1.9730609360316453, 1.9768489580079589]
- log10 r :: [0.0, 0.14999999999999999, 0.29999999999999999, 0.44999999999999996, 0.59999999999999998, 0.75, 0.89999999999999991, 1.05, 1.2, 1.3499999999999999]
- Unweighted B(r) :: [1.9111971390912388, 1.9326219633257189, 2.0221869704917208, 1.9489318348096289, 2.0172164316174075, 1.984552260129967, 1.9841030114797624, 1.9928877959047415, 1.9730609360316453, 1.9768489580079589]
- Sum weights :: [870.0, 1682.0, 4088.0, 8534.0, 17424.0, 30000.0, 56074.0, 83308.0, 108730.0, 75258.0]
- Sum dv^2 :: [1662.7415110093777, 3250.6701423138593, 8266.7003353701548, 16632.184278265373, 35147.979104501705, 59536.567803899008, 111256.5922657162, 166023.49650123221, 214530.9155747208, 148773.69888176298]


#+BEGIN_SRC ipython :results list
  test_strucfunc(n=30, func=strucfunc.strucfunc_numba_futures, numthreads=4)
#+END_SRC

#+RESULTS:
- Sum weights :: [870.0, 5.6424915977472235e+276, 1.1284983195494473e+277, 2.8212457988736213e+277, 6.2067407575219662e+277, 1.2413481515043951e+278, 2.3134215550763769e+278, 2.6519710509412256e+278, 3.4983447906032827e+278, 4.4575683622203129e+278]
- N pairs :: [870, 1694, 4115, 8606, 17581, 30312, 56727, 84453, 110690, 78241]
- Unweighted B(r) :: [2.026277824224473, 2.0434219259572663, 2.0858015105521894, 2.1314437401811159, 2.0827494293075675, 2.0927400281419795, 2.0528293571648839, 2.0563164545581989, 2.0400882721612561, 1.9050887029975545]
- Sum dv^2 :: [1762.8617070752914, 3461.5567425716094, 8583.0732159222589, 18343.204827998685, 36616.81771665634, 63435.135733039686, 116450.85094389238, 173662.09353680359, 225817.37084552943, 149056.04521123166]
- Weighted B(r) :: [2.026277824224473, 0.0021318595694591064, 0.17178049855249231, 0.91239094995103986, 2.314967069324398, 1.8814547219458795, 2.3133031637587855, 1.9625547525652187, 2.081434162335174, 1.8261594720294774]
- log10 r :: [0.0, 0.14999999999999999, 0.29999999999999999, 0.44999999999999996, 0.59999999999999998, 0.75, 0.89999999999999991, 1.05, 1.2, 1.3499999999999999]
- Sum w * dv^2 :: [1762.8617070752914, 1.2028999708250022e+274, 1.9385400394785381e+276, 2.5740791344796836e+277, 1.436840046149692e+278, 2.3355403412267332e+278, 5.3516454024659518e+278, 5.2046383896900799e+278, 7.2815743587889637e+278, 8.140230686887549e+278]


#+BEGIN_SRC ipython :results list
  test_strucfunc(n=200, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
- Sum weights :: [39800.0, 79202.0, 197208.0, 430644.0, 931174.0, 1759750.0, 3756974.0, 7014208.0, 13618460.0, 25526822.0, 47669822.0, 84088020.0, 138263880.0, 199521906.0, 210520624.0, 62229760.0]
- N pairs :: [39800, 79202, 197208, 430644, 931174, 1759750, 3756974, 7014208, 13618460, 25526822, 47669822, 84088020, 138263880, 199521906, 210520624, 62229760]
- Sum dv^2 :: [79528.907946145919, 161123.92313008237, 398093.31059542822, 868024.86421163136, 1882366.0656988928, 3556077.5329574114, 7584163.2405801686, 14158891.448045129, 27486743.562336277, 51575146.84693604, 96389502.05759567, 170107571.94206303, 279861760.88147771, 403227000.98669356, 423336073.97693521, 124199338.09902725]
- log10 r :: [0.0, 0.14999999999999999, 0.29999999999999999, 0.44999999999999996, 0.59999999999999998, 0.75, 0.89999999999999991, 1.05, 1.2, 1.3499999999999999, 1.5, 1.6499999999999999, 1.7999999999999998, 1.95, 2.1000000000000001, 2.25]
- Weighted B(r) :: [1.9982137674911036, 2.034341596551632, 2.018646863187235, 2.0156436969088882, 2.021497663915544, 2.0207856416862686, 2.0186893070274556, 2.0186015938000597, 2.0183444796501422, 2.0204296032986808, 2.022023536349594, 2.0229703582277598, 2.0241133178200821, 2.0209660636797122, 2.0109007181022567, 1.9958190116598111]
- Sum w * dv^2 :: [79528.907946145919, 161123.92313008237, 398093.31059542822, 868024.86421163136, 1882366.0656988928, 3556077.5329574114, 7584163.2405801686, 14158891.448045129, 27486743.562336277, 51575146.84693604, 96389502.05759567, 170107571.94206303, 279861760.88147771, 403227000.98669356, 423336073.97693521, 124199338.09902725]
- Unweighted B(r) :: [1.9982137674911036, 2.034341596551632, 2.018646863187235, 2.0156436969088882, 2.021497663915544, 2.0207856416862686, 2.0186893070274556, 2.0186015938000597, 2.0183444796501422, 2.0204296032986808, 2.022023536349594, 2.0229703582277598, 2.0241133178200821, 2.0209660636797122, 2.0109007181022567, 1.9958190116598111]

*** Conclusions on timing
+ Numba is the fastest by far
  + Timings are consistent with N^4 trend
  + Extrapolation to N=1500 would give t = 18.7 hrs
  + So we need to further increase the efficiency
    + [X] Maybe with nogil=True and parallelism
    + [ ] Or vectorize inner loops with Accelerate?
  + Multithreading with =concurrent.futures= works great
    + Speed-up is nearly a factor of 5 with 8 threads
      + Which is similar to what I get with openMP+Fortran
  + Extrapolation to 1600x1600 now gives t = 80 * 40**4 / 3600 = 5.7 hours
    + May be even faster on the iMac

**** Hypatia timings (Imac 5k)
|   N | Numpy | Numba |  N=1 |   N=2 |   N=4 |   N=5 |  N=8 |  N=10 |  N=20 |
|-----+-------+-------+------+-------+-------+-------+------+-------+-------|
|  50 |  2.09 | 0.072 |      |       |       |       |      |       |       |
| 100 |       |  1.15 | 1.32 | 0.801 | 0.545 | 0.532 |      | 0.479 | 0.492 |
| 200 |       |  18.5 | 17.0 |  8.74 |  4.66 |       | 3.54 |  3.51 |  3.52 |
| 400 |       |       |      |       |       |       |      |    52 |       |

**** Iris timings (Macbook Pro)
|   N | Python | Numpy | Numba | 2 Threads | 4 Threads | 8 Threads | 50 Threads |
|-----+--------+-------+-------+-----------+-----------+-----------+------------|
|  50 |   14.8 |  2.47 | 0.085 |           |           |           |            |
| 100 |        |    30 |  1.33 |           |           |           |            |
| 200 |        |       | 21.29 |           |      5.76 |      4.49 |       4.59 |
| 400 |        |       |       |           |           |        80 |            |

*** Now some timings

**** N=50 - pure python
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=50, func=strucfunc.strucfunc_python)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 14.8 s per loop

**** N=50 - numpy histogram
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=50, func=strucfunc.strucfunc_numpy)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 2.47 s per loop

**** N=50 - numba acceleration
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=50, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
: 10 loops, best of 3: 85 ms per loop

Wow, that was fast!


**** N=100 - numba acceleration
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 1.33 s per loop

**** N=200 - numba multithreading with 4 threads
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 5.76 s per loop

**** N=200 - numba multithreading with 8 threads
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=8)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 4.49 s per loop


**** N=200 - numba multithreading with 50 threads
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=50)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 4.59 s per loop

**** N=200 - numba acceleration
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 21.9 s per loop


**** N=400 - numba multithreading with 8 threads
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=400, func=strucfunc.strucfunc_numba_futures, numthreads=8)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 1min 20s per loop


**** N=100 - numpy histogram
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numpy)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 30 s per loop

*** Repeat timings on hypatia
**** Hypatia - N=50 - numpy histogram
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=50, func=strucfunc.strucfunc_numpy)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 2.09 s per loop

Slightly faster than laptop
**** Hypatia - N=50 - numba acceleration
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=50, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
: 10 loops, best of 3: 72 ms per loop

Again slightly faster


**** Hypatia - N=100 - numba acceleration and multi-threading
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 1.15 s per loop

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba_futures, numthreads=1)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 1.32 s per loop

So =concurrent.futures= incurs a slight overhead of about 15% when restricted to 1 thread. 

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba_futures, numthreads=2)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 801 ms per loop

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba_futures, numthreads=4)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 545 ms per loop

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba_futures, numthreads=5)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 532 ms per loop

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba_futures, numthreads=10)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 479 ms per loop

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=100, func=strucfunc.strucfunc_numba_futures, numthreads=20)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 492 ms per loop

So there is some gain in having more threads than processors, but N=10 seems about optimum. 


**** Hypatia - N=200 - numba acceleration and multi-threading
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 18.5 s per loop

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=1)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 17 s per loop

*Interesting* - with larger arrays, even single-threaded version is faster with futures. 

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=2)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 8.74 s per loop

Speed-up is factor of 1.945 with 2 threads

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=4)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 4.66 s per loop

Speed-up is factor of 3.65 with 4 threads

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=8)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 3.54 s per loop

Speed-up is factor of 4.8 with 8 threads

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=10)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 3.51 s per loop

Speed-up is factor of 4.84 with 10 threads

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=200, func=strucfunc.strucfunc_numba_futures, numthreads=20)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 3.52 s per loop

And similar with 20 threads

So there is some gain in having more threads than processors, but N=10 seems about optimum. 


**** Hypatia - N=400 - numba acceleration and multi-threading
#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=400, func=strucfunc.strucfunc_numba_futures, numthreads=4)
#+END_SRC

#+BEGIN_SRC ipython :results output verbatim
%timeit test_strucfunc(n=400, func=strucfunc.strucfunc_numba_futures, numthreads=10)
#+END_SRC

#+RESULTS:
: 1 loop, best of 3: 52 s per loop

So that is 50% faster than the best I was obtaining on my laptop. 

*** Inspect what numba was doing behind the scenes
#+BEGIN_SRC ipython :results output verbatim
strucfunc.strucfunc_numba_futures.inspect_types()
#+END_SRC



#+BEGIN_SRC ipython :results output verbatim
strucfunc.strucfunc_numba.inspect_types()
#+END_SRC

#+RESULTS:
#+begin_example
strucfunc_numba (array(float64, 2d, C), omitted(default=0.15), array(float64, 2d, C), omitted(default=0.001))
--------------------------------------------------------------------------------
# File: /Users/will/Dropbox/muse-strucfunc/strucfunc.py
# --- LINE 57 --- 

@numba.jit

# --- LINE 58 --- 

def strucfunc_numba(vmap, dlogr=0.15, wmap=None, wmin_factor=1e-3):

    # --- LINE 59 --- 

    """Calculate structure function via naive python algorithm"""

    # --- LINE 60 --- 
    # label 0
    #   vmap = arg(0, name=vmap)  :: pyobject
    #   dlogr = arg(1, name=dlogr)  :: pyobject
    #   wmap = arg(2, name=wmap)  :: pyobject
    #   wmin_factor = arg(3, name=wmin_factor)  :: pyobject
    #   $0.2 = getattr(attr=shape, value=vmap)  :: pyobject
    #   $0.5 = exhaust_iter(count=2, value=$0.2)  :: pyobject
    #   del $0.2
    #   $0.3 = static_getitem(index_var=None, index=0, value=$0.5)  :: pyobject
    #   $0.4 = static_getitem(index_var=None, index=1, value=$0.5)  :: pyobject
    #   del $0.5
    #   ny = $0.3  :: pyobject
    #   del $0.3
    #   nx = $0.4  :: pyobject
    #   del $0.4
    #   del $const0.7

    ny, nx = vmap.shape

    # --- LINE 61 --- 
    #   $const0.7 = const(NoneType, None)  :: pyobject
    #   $0.8 = wmap is $const0.7  :: pyobject
    #   branch $0.8, 27, 42

    if wmap is None:

        # --- LINE 62 --- 
        # label 27
        #   del $0.8
        #   $27.1 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
        #   $27.2 = getattr(attr=ones_like, value=$27.1)  :: pyobject
        #   del $27.1
        #   $27.4 = call $27.2(vmap)  :: pyobject
        #   del $27.2
        #   wmap = $27.4  :: pyobject
        #   del $27.4

        wmap = np.ones_like(vmap)

    # --- LINE 63 --- 
    #   jump 42
    # label 42
    #   del $0.8
    #   $42.2 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.3 = getattr(attr=nanmax, value=$42.2)  :: pyobject
    #   del $42.2
    #   $42.5 = call $42.3(wmap)  :: pyobject
    #   del $42.3
    #   $42.6 = wmin_factor * $42.5  :: pyobject
    #   del wmin_factor
    #   del $42.5
    #   wmin = $42.6  :: pyobject
    #   del $42.6
    #   del $42.7
    #   del $42.8
    #   del $42.11
    #   del $42.13
    #   del maxr
    #   del $42.14
    #   del $42.16
    #   del $42.18
    #   del $42.12
    #   del $42.19
    #   del $42.20
    #   del $42.21
    #   del $42.23
    #   del $42.25
    #   del $42.26
    #   del $42.27
    #   del $42.29
    #   del $42.30
    #   del $42.31
    #   del $42.33
    #   del $42.35
    #   del $42.34
    #   del $42.36
    #   del $42.37
    #   del $42.38
    #   del $42.40
    #   del $42.41
    #   del $42.42
    #   del $42.44

    wmin = wmin_factor*np.nanmax(wmap)

    # --- LINE 64 --- 
    #   $42.7 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.8 = getattr(attr=hypot, value=$42.7)  :: pyobject
    #   $42.11 = call $42.8(nx, ny)  :: pyobject
    #   maxr = $42.11  :: pyobject

    maxr = np.hypot(nx, ny)

    # --- LINE 65 --- 
    #   $42.12 = global(int: <class 'int'>)  :: pyobject
    #   $42.13 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.14 = getattr(attr=log10, value=$42.13)  :: pyobject
    #   $42.16 = call $42.14(maxr)  :: pyobject
    #   $42.18 = $42.16 / dlogr  :: pyobject
    #   $42.19 = call $42.12($42.18)  :: pyobject
    #   nr = $42.19  :: pyobject

    nr = int(np.log10(maxr)/dlogr)

    # --- LINE 66 --- 
    #   $42.20 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.21 = getattr(attr=arange, value=$42.20)  :: pyobject
    #   $42.23 = call $42.21(nr)  :: pyobject
    #   $42.25 = $42.23 * dlogr  :: pyobject
    #   logr = $42.25  :: pyobject

    logr = np.arange(nr)*dlogr

    # --- LINE 67 --- 
    #   $42.26 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.27 = getattr(attr=zeros_like, value=$42.26)  :: pyobject
    #   $42.29 = call $42.27(logr)  :: pyobject
    #   sf = $42.29  :: pyobject

    sf = np.zeros_like(logr)

    # --- LINE 68 --- 
    #   $42.30 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.31 = getattr(attr=zeros_like, value=$42.30)  :: pyobject
    #   $42.33 = call $42.31(logr)  :: pyobject
    #   $42.34 = getattr(attr=astype, value=$42.33)  :: pyobject
    #   $42.35 = global(int: <class 'int'>)  :: pyobject
    #   $42.36 = call $42.34($42.35)  :: pyobject
    #   nsf = $42.36  :: pyobject

    nsf = np.zeros_like(logr).astype(int)

    # --- LINE 69 --- 
    #   $42.37 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.38 = getattr(attr=zeros_like, value=$42.37)  :: pyobject
    #   $42.40 = call $42.38(logr)  :: pyobject
    #   wsf = $42.40  :: pyobject

    wsf = np.zeros_like(logr)

    # --- LINE 70 --- 
    #   $42.41 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: pyobject
    #   $42.42 = getattr(attr=zeros_like, value=$42.41)  :: pyobject
    #   $42.44 = call $42.42(logr)  :: pyobject
    #   weight = $42.44  :: pyobject

    weight = np.zeros_like(logr)

# --- LINE 71 --- 



    # --- LINE 72 --- 
    #   jump 192
    # label 192
    #   jump 195
    # label 195
    #   $233 = const(LiftedLoop, LiftedLoop(<function strucfunc_numba at 0x1053879d8>))  :: XXX Lifted Loop XXX
    #   $234 = call $233(dlogr, logr, nr, nsf, nx, ny, sf, vmap, weight, wmap, wmin, wsf)  :: XXX Lifted Loop XXX
    #   del wmin
    #   del wmap
    #   del vmap
    #   del ny
    #   del nx
    #   del nr
    #   del dlogr
    #   del $233
    #   logr = static_getitem(index_var=None, index=0, value=$234)  :: pyobject
    #   nsf = static_getitem(index_var=None, index=1, value=$234)  :: pyobject
    #   sf = static_getitem(index_var=None, index=2, value=$234)  :: pyobject
    #   weight = static_getitem(index_var=None, index=3, value=$234)  :: pyobject
    #   wsf = static_getitem(index_var=None, index=4, value=$234)  :: pyobject
    #   del $234
    #   jump 538

    for j in range(ny):

        # --- LINE 73 --- 

        for i in range(nx):

            # --- LINE 74 --- 

            for jj in range(ny):

                # --- LINE 75 --- 

                for ii in range(i+1, nx):

                    # --- LINE 76 --- 

                    r = np.hypot(ii - i, jj - j)

                    # --- LINE 77 --- 

                    ir = int(np.log10(r)/dlogr)

                    # --- LINE 78 --- 

                    if 0 <= ir < nr:

                        # --- LINE 79 --- 

                        dvsq = (vmap[jj, ii] - vmap[j, i])**2

                        # --- LINE 80 --- 

                        if (wmap[j, i] > wmin) and (wmap[jj, ii] > wmin):

                            # --- LINE 81 --- 

                            sf[ir] += dvsq

                            # --- LINE 82 --- 

                            nsf[ir] += 1

                        # --- LINE 83 --- 

                        w = wmap[j, i]*wmap[jj, ii]

                        # --- LINE 84 --- 

                        wsf[ir] += w*dvsq

                        # --- LINE 85 --- 

                        weight[ir] += w

# --- LINE 86 --- 



    # --- LINE 87 --- 
    # label 538
    #   $const538.1 = const(str, log10 r)  :: pyobject
    #   del wsf
    #   del weight
    #   del sf
    #   del nsf
    #   del logr
    #   del $const538.9
    #   del $const538.7
    #   del $const538.5
    #   del $const538.3
    #   del $const538.15
    #   del $const538.11
    #   del $const538.1
    #   del $538.18
    #   del $538.14
    #   del $538.19

    return {'log10 r': logr,

            # --- LINE 88 --- 
            #   $const538.3 = const(str, Sum dv^2)  :: pyobject

            'Sum dv^2': sf,

            # --- LINE 89 --- 
            #   $const538.5 = const(str, Sum weights)  :: pyobject

            'Sum weights': weight,

            # --- LINE 90 --- 
            #   $const538.7 = const(str, Sum w * dv^2)  :: pyobject

            'Sum w * dv^2': wsf,

            # --- LINE 91 --- 
            #   $const538.9 = const(str, N pairs)  :: pyobject

            'N pairs': nsf,

            # --- LINE 92 --- 
            #   $const538.11 = const(str, Unweighted B(r))  :: pyobject
            #   $538.14 = sf / nsf  :: pyobject

            'Unweighted B(r)': sf/nsf,

            # --- LINE 93 --- 
            #   $const538.15 = const(str, Weighted B(r))  :: pyobject
            #   $538.18 = wsf / weight  :: pyobject
            #   $538.19 = build_map(size=7, items=[(Var($const538.1, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (87)), Var(logr, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (66))), (Var($const538.3, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (88)), Var(sf, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (67))), (Var($const538.5, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (89)), Var(weight, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (70))), (Var($const538.7, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (90)), Var(wsf, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (69))), (Var($const538.9, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (91)), Var(nsf, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (68))), (Var($const538.11, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (92)), Var($538.14, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (92))), (Var($const538.15, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (93)), Var($538.18, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (93)))])  :: pyobject
            #   $538.20 = cast(value=$538.19)  :: pyobject
            #   return $538.20

            'Weighted B(r)': wsf/weight}

# The function contains lifted loops
# Loop at line 72
# Has 1 overloads
# File: /Users/will/Dropbox/muse-strucfunc/strucfunc.py
# --- LINE 57 --- 

@numba.jit

# --- LINE 58 --- 

def strucfunc_numba(vmap, dlogr=0.15, wmap=None, wmin_factor=1e-3):

    # --- LINE 59 --- 

    """Calculate structure function via naive python algorithm"""

    # --- LINE 60 --- 

    ny, nx = vmap.shape

    # --- LINE 61 --- 

    if wmap is None:

        # --- LINE 62 --- 

        wmap = np.ones_like(vmap)

    # --- LINE 63 --- 

    wmin = wmin_factor*np.nanmax(wmap)

    # --- LINE 64 --- 

    maxr = np.hypot(nx, ny)

    # --- LINE 65 --- 

    nr = int(np.log10(maxr)/dlogr)

    # --- LINE 66 --- 

    logr = np.arange(nr)*dlogr

    # --- LINE 67 --- 

    sf = np.zeros_like(logr)

    # --- LINE 68 --- 

    nsf = np.zeros_like(logr).astype(int)

    # --- LINE 69 --- 

    wsf = np.zeros_like(logr)

    # --- LINE 70 --- 

    weight = np.zeros_like(logr)

# --- LINE 71 --- 



    # --- LINE 72 --- 
    # label 194
    #   dlogr = arg(0, name=dlogr)  :: float64
    #   logr = arg(1, name=logr)  :: array(float64, 1d, C)
    #   nr = arg(2, name=nr)  :: int64
    #   nsf = arg(3, name=nsf)  :: array(int64, 1d, C)
    #   nx = arg(4, name=nx)  :: int64
    #   ny = arg(5, name=ny)  :: int64
    #   sf = arg(6, name=sf)  :: array(float64, 1d, C)
    #   vmap = arg(7, name=vmap)  :: array(float64, 2d, C)
    #   weight = arg(8, name=weight)  :: array(float64, 1d, C)
    #   wmap = arg(9, name=wmap)  :: array(float64, 2d, C)
    #   wmin = arg(10, name=wmin)  :: float64
    #   wsf = arg(11, name=wsf)  :: array(float64, 1d, C)
    #   jump 195
    # label 195
    #   $195.1 = global(range: <class 'range'>)  :: Function(<class 'range'>)
    #   $195.3 = call $195.1(ny)  :: (int64,) -> range_state_int64
    #   del $195.1
    #   $195.4 = getiter(value=$195.3)  :: range_iter_int64
    #   del $195.3
    #   $phi205.1 = $195.4  :: range_iter_int64
    #   del $195.4
    #   jump 205
    # label 205
    #   $205.2 = iternext(value=$phi205.1)  :: pair<int64, bool>
    #   $205.3 = pair_first(value=$205.2)  :: int64
    #   $205.4 = pair_second(value=$205.2)  :: bool
    #   del $205.2
    #   $phi208.1 = $205.3  :: int64
    #   del $205.3
    #   branch $205.4, 208, 537
    # label 208
    #   del $205.4
    #   j = $phi208.1  :: int64
    #   del $phi208.1
    # label 538
    #   $232 = build_tuple(items=[Var(logr, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (66)), Var(nsf, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (68)), Var(sf, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (67)), Var(weight, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (70)), Var(wsf, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (69))])  :: (array(float64, 1d, C), array(int64, 1d, C), array(float64, 1d, C), array(float64, 1d, C), array(float64, 1d, C))
    #   del wsf
    #   del weight
    #   del sf
    #   del nsf
    #   del logr
    #   return $232

    for j in range(ny):

        # --- LINE 73 --- 
        #   jump 211
        # label 211
        #   jump 214
        # label 214
        #   $214.1 = global(range: <class 'range'>)  :: Function(<class 'range'>)
        #   $214.3 = call $214.1(nx)  :: (int64,) -> range_state_int64
        #   del $214.1
        #   $214.4 = getiter(value=$214.3)  :: range_iter_int64
        #   del $214.3
        #   $phi224.1 = $214.4  :: range_iter_int64
        #   del $214.4
        #   jump 224
        # label 224
        #   $224.2 = iternext(value=$phi224.1)  :: pair<int64, bool>
        #   $224.3 = pair_first(value=$224.2)  :: int64
        #   $224.4 = pair_second(value=$224.2)  :: bool
        #   del $224.2
        #   $phi227.1 = $224.3  :: int64
        #   del $224.3
        #   branch $224.4, 227, 533
        # label 227
        #   del $224.4
        #   i = $phi227.1  :: int64
        #   del $phi227.1

        for i in range(nx):

            # --- LINE 74 --- 
            #   jump 230
            # label 230
            #   jump 233
            # label 233
            #   $233.1 = global(range: <class 'range'>)  :: Function(<class 'range'>)
            #   $233.3 = call $233.1(ny)  :: (int64,) -> range_state_int64
            #   del $233.1
            #   $233.4 = getiter(value=$233.3)  :: range_iter_int64
            #   del $233.3
            #   $phi243.1 = $233.4  :: range_iter_int64
            #   del $233.4
            #   jump 243
            # label 243
            #   $243.2 = iternext(value=$phi243.1)  :: pair<int64, bool>
            #   $243.3 = pair_first(value=$243.2)  :: int64
            #   $243.4 = pair_second(value=$243.2)  :: bool
            #   del $243.2
            #   $phi246.1 = $243.3  :: int64
            #   del $243.3
            #   branch $243.4, 246, 529
            # label 246
            #   del $243.4
            #   jj = $phi246.1  :: int64
            #   del $phi246.1

            for jj in range(ny):

                # --- LINE 75 --- 
                #   jump 249
                # label 249
                #   jump 252
                # label 252
                #   $252.1 = global(range: <class 'range'>)  :: Function(<class 'range'>)
                #   $const252.3 = const(int, 1)  :: int64
                #   $252.4 = i + $const252.3  :: int64
                #   del $const252.3
                #   $252.6 = call $252.1($252.4, nx)  :: (int64, int64) -> range_state_int64
                #   del $252.4
                #   del $252.1
                #   $252.7 = getiter(value=$252.6)  :: range_iter_int64
                #   del $252.6
                #   $phi269.1 = $252.7  :: range_iter_int64
                #   del $252.7
                #   jump 269
                # label 269
                #   del ir
                #   del ii
                #   del $phi351.1
                #   $269.2 = iternext(value=$phi269.1)  :: pair<int64, bool>
                #   $269.3 = pair_first(value=$269.2)  :: int64
                #   $269.4 = pair_second(value=$269.2)  :: bool
                #   del $269.2
                #   $phi272.1 = $269.3  :: int64
                #   del $269.3
                #   branch $269.4, 272, 525
                # label 272
                #   del $269.4
                #   ii = $phi272.1  :: int64
                #   del $phi272.1
                #   del $272.2
                #   del $272.9
                #   del $272.6
                #   del $272.3
                #   del $272.10
                #   del $272.12
                #   del r
                #   del $272.13
                #   del $272.15
                #   del $272.17
                #   del $272.11
                #   del $272.18
                #   del $const272.19
                #   del $phi349.2

                for ii in range(i+1, nx):

                    # --- LINE 76 --- 
                    #   $272.2 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: Module(<module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)
                    #   $272.3 = getattr(attr=hypot, value=$272.2)  :: Function(<ufunc 'hypot'>)
                    #   $272.6 = ii - i  :: int64
                    #   $272.9 = jj - j  :: int64
                    #   $272.10 = call $272.3($272.6, $272.9)  :: (int64, int64) -> float64
                    #   r = $272.10  :: float64

                    r = np.hypot(ii - i, jj - j)

                    # --- LINE 77 --- 
                    #   $272.11 = global(int: <class 'int'>)  :: Function(<class 'int'>)
                    #   $272.12 = global(np: <module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)  :: Module(<module 'numpy' from '/Users/will/anaconda/lib/python3.5/site-packages/numpy/__init__.py'>)
                    #   $272.13 = getattr(attr=log10, value=$272.12)  :: Function(<ufunc 'log10'>)
                    #   $272.15 = call $272.13(r)  :: (float64,) -> float64
                    #   $272.17 = $272.15 / dlogr  :: float64
                    #   $272.18 = call $272.11($272.17)  :: (float64,) -> int64
                    #   ir = $272.18  :: int64

                    ir = int(np.log10(r)/dlogr)

                    # --- LINE 78 --- 
                    #   $const272.19 = const(int, 0)  :: int64
                    #   $272.22 = $const272.19 <= ir  :: bool
                    #   $phi349.2 = ir  :: int64
                    #   $phi349.1 = $272.22  :: bool
                    #   $phi340.2 = ir  :: int64
                    #   branch $272.22, 340, 349
                    # label 340
                    #   del $phi349.1
                    #   del $272.22
                    #   $340.3 = $phi340.2 < nr  :: bool
                    #   del $phi340.2
                    #   $phi351.1 = $340.3  :: bool
                    #   del $340.3
                    #   jump 351
                    # label 349
                    #   del $phi340.2
                    #   del $272.22
                    #   $phi351.1 = $phi349.1  :: bool
                    #   del $phi349.1
                    #   jump 351
                    # label 351
                    #   branch $phi351.1, 354, 269

                    if 0 <= ir < nr:

                        # --- LINE 79 --- 
                        # label 354
                        #   del $phi351.1
                        #   $354.4 = build_tuple(items=[Var(jj, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (74)), Var(ii, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (75))])  :: (int64 x 2)
                        #   $354.5 = getitem(index=$354.4, value=vmap)  :: float64
                        #   del $354.4
                        #   $354.9 = build_tuple(items=[Var(j, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (72)), Var(i, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (73))])  :: (int64 x 2)
                        #   $354.10 = getitem(index=$354.9, value=vmap)  :: float64
                        #   del $354.9
                        #   $354.11 = $354.5 - $354.10  :: float64
                        #   del $354.5
                        #   del $354.10
                        #   $const354.12 = const(int, 2)  :: int64
                        #   $354.13 = $354.11 ** $const354.12  :: float64
                        #   del $const354.12
                        #   del $354.11
                        #   dvsq = $354.13  :: float64
                        #   del $354.13
                        #   del $354.17
                        #   del $354.18

                        dvsq = (vmap[jj, ii] - vmap[j, i])**2

                        # --- LINE 80 --- 
                        #   $354.17 = build_tuple(items=[Var(j, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (72)), Var(i, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (73))])  :: (int64 x 2)
                        #   $354.18 = getitem(index=$354.17, value=wmap)  :: float64
                        #   $354.20 = $354.18 > wmin  :: bool
                        #   branch $354.20, 410, 460
                        # label 410
                        #   del $354.20
                        #   $410.4 = build_tuple(items=[Var(jj, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (74)), Var(ii, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (75))])  :: (int64 x 2)
                        #   $410.5 = getitem(index=$410.4, value=wmap)  :: float64
                        #   del $410.4
                        #   $410.7 = $410.5 > wmin  :: bool
                        #   del $410.5
                        #   branch $410.7, 432, 460

                        if (wmap[j, i] > wmin) and (wmap[jj, ii] > wmin):

                            # --- LINE 81 --- 
                            # label 432
                            #   del $410.7
                            #   $432.5 = getitem(index=ir, value=sf)  :: float64
                            #   $432.7 = inplace_binop(fn=+=, static_lhs=<object object at 0x10072e2e0>, immutable_fn=+, static_rhs=<object object at 0x10072e2e0>, lhs=$432.5, rhs=dvsq)  :: float64
                            #   del $432.5
                            #   sf[ir] = $432.7  :: (array(float64, 1d, C), int64, float64) -> none
                            #   del $432.7
                            #   del $const432.13
                            #   del $432.12
                            #   del $432.14

                            sf[ir] += dvsq

                            # --- LINE 82 --- 
                            #   $432.12 = getitem(index=ir, value=nsf)  :: int64
                            #   $const432.13 = const(int, 1)  :: int64
                            #   $432.14 = inplace_binop(fn=+=, static_lhs=<object object at 0x10072e2e0>, immutable_fn=+, static_rhs=<object object at 0x10072e2e0>, lhs=$432.12, rhs=$const432.13)  :: int64
                            #   nsf[ir] = $432.14  :: (array(int64, 1d, C), int64, int64) -> none

                            nsf[ir] += 1

                        # --- LINE 83 --- 
                        #   jump 460
                        # label 460
                        #   del $410.7
                        #   del $354.20
                        #   $460.4 = build_tuple(items=[Var(j, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (72)), Var(i, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (73))])  :: (int64 x 2)
                        #   $460.5 = getitem(index=$460.4, value=wmap)  :: float64
                        #   del $460.4
                        #   $460.9 = build_tuple(items=[Var(jj, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (74)), Var(ii, /Users/will/Dropbox/muse-strucfunc/strucfunc.py (75))])  :: (int64 x 2)
                        #   del ii
                        #   $460.10 = getitem(index=$460.9, value=wmap)  :: float64
                        #   del $460.9
                        #   $460.11 = $460.5 * $460.10  :: float64
                        #   del $460.5
                        #   del $460.10
                        #   w = $460.11  :: float64
                        #   del $460.11
                        #   del dvsq
                        #   del $460.19
                        #   del $460.16
                        #   del $460.20
                        #   del w
                        #   del $460.25
                        #   del ir
                        #   del $460.27

                        w = wmap[j, i]*wmap[jj, ii]

                        # --- LINE 84 --- 
                        #   $460.16 = getitem(index=ir, value=wsf)  :: float64
                        #   $460.19 = w * dvsq  :: float64
                        #   $460.20 = inplace_binop(fn=+=, static_lhs=<object object at 0x10072e2e0>, immutable_fn=+, static_rhs=<object object at 0x10072e2e0>, lhs=$460.16, rhs=$460.19)  :: float64
                        #   wsf[ir] = $460.20  :: (array(float64, 1d, C), int64, float64) -> none

                        wsf[ir] += w*dvsq

                        # --- LINE 85 --- 
                        #   $460.25 = getitem(index=ir, value=weight)  :: float64
                        #   $460.27 = inplace_binop(fn=+=, static_lhs=<object object at 0x10072e2e0>, immutable_fn=+, static_rhs=<object object at 0x10072e2e0>, lhs=$460.25, rhs=w)  :: float64
                        #   weight[ir] = $460.27  :: (array(float64, 1d, C), int64, float64) -> none
                        #   jump 269
                        # label 525
                        #   del jj
                        #   del $phi272.1
                        #   del $phi269.1
                        #   del $269.4
                        #   jump 526
                        # label 526
                        #   jump 243
                        # label 529
                        #   del i
                        #   del $phi246.1
                        #   del $phi243.1
                        #   del $243.4
                        #   jump 530
                        # label 530
                        #   jump 224
                        # label 533
                        #   del j
                        #   del $phi227.1
                        #   del $phi224.1
                        #   del $224.4
                        #   jump 534
                        # label 534
                        #   jump 205
                        # label 537
                        #   del wmin
                        #   del wmap
                        #   del vmap
                        #   del ny
                        #   del nx
                        #   del nr
                        #   del dlogr
                        #   del $phi208.1
                        #   del $phi205.1
                        #   del $205.4

                        weight[ir] += w

# --- LINE 86 --- 



    # --- LINE 87 --- 
    #   jump 538

    return {'log10 r': logr,

            # --- LINE 88 --- 

            'Sum dv^2': sf,

            # --- LINE 89 --- 

            'Sum weights': weight,

            # --- LINE 90 --- 

            'Sum w * dv^2': wsf,

            # --- LINE 91 --- 

            'N pairs': nsf,

            # --- LINE 92 --- 

            'Unweighted B(r)': sf/nsf,

            # --- LINE 93 --- 

            'Weighted B(r)': wsf/weight}



================================================================================
#+end_example


** Parallelization strategies
+ The easiest way would seem to be just using threads with GIL released
+ In the numba docs example this is done with =threading.Thread=
+ But it might be better to use =concurrent.futures=
  + [X] First task is to re-write =make_multithread= to use the =concurrent.futures= API
  + [ ] Second task will be to adapt this for my own strucfunc function
    + We need to restructure the function a bit first


* Multi-threading example from numba docs
#+header: :tangle mt-numba-example.py :eval no :shebang "#!/usr/bin/env python"
#+BEGIN_SRC python
    from __future__ import print_function, division, absolute_import
    import sys
    import math
    import threading
    from concurrent import futures
    from timeit import repeat

    import numpy as np
    from numba import jit

    nthreads = 4
    try:
        size = float(sys.argv[1])
    except IndexError:
        size = 1e6

    def func_np(a, b):
        """
        Control function using Numpy.
        """
        return np.exp(2.1 * a + 3.2 * b)

    @jit('void(double[:], double[:], double[:])', nopython=True, nogil=True)
    def inner_func_nb(result, a, b):
        """
        Function under test.
        """
        for i in range(len(result)):
            result[i] = math.exp(2.1 * a[i] + 3.2 * b[i])

    def timefunc(correct, s, func, *args, **kwargs):
        """
        Benchmark *func* and print out its runtime.
        """
        print(s.ljust(20), end=" ")
        # Make sure the function is compiled before we start the benchmark
        res = func(*args, **kwargs)
        if correct is not None:
            assert np.allclose(res, correct), (res, correct)
        # time it
        print('{:>5.0f} ms'.format(min(repeat(lambda: func(*args, **kwargs),
                                              number=5, repeat=2)) * 1000))
        return res

    def make_singlethread(inner_func):
        """
        Run the given function inside a single thread.
        """
        def func(*args):
            length = len(args[0])
            result = np.empty(length, dtype=np.float64)
            inner_func(result, *args)
            return result
        return func


    def make_multithread_future(inner_func, numthreads):
        """
        Run the given function inside *numthreads* threads, splitting its
        arguments into equal-sized chunks. Implemented using futures

        WJH 10 Oct 2016
        """
        def func_mt(*args):
            length = len(args[0])
            result = np.empty(length, dtype=np.float64)
            args = (result,) + args
            chunklen = (length + numthreads - 1) // numthreads
            # Create argument tuples for each input chunk
            chunks = [[arg[i * chunklen:(i + 1) * chunklen] for arg in args]
                      for i in range(numthreads)]
            # Spawn one thread per chunk
            with futures.ThreadPoolExecutor(max_workers=numthreads) as ex:
                for chunk in chunks:
                    ex.submit(inner_func, *chunk)
            return result
        return func_mt


    def make_multithread(inner_func, numthreads):
        """
        Run the given function inside *numthreads* threads, splitting its
        arguments into equal-sized chunks.
        """
        def func_mt(*args):
            length = len(args[0])
            result = np.empty(length, dtype=np.float64)
            args = (result,) + args
            chunklen = (length + numthreads - 1) // numthreads
            # Create argument tuples for each input chunk
            chunks = [[arg[i * chunklen:(i + 1) * chunklen] for arg in args]
                      for i in range(numthreads)]
            # Spawn one thread per chunk
            threads = [threading.Thread(target=inner_func, args=chunk)
                       for chunk in chunks]
            for thread in threads:
                thread.start()
            for thread in threads:
                thread.join()
            return result
        return func_mt


    func_nb = make_singlethread(inner_func_nb)
    func_nb_mt = make_multithread_future(inner_func_nb, nthreads)

    a = np.random.rand(size)
    b = np.random.rand(size)

    correct = timefunc(None, "numpy (1 thread)", func_np, a, b)
    timefunc(correct, "numba (1 thread)", func_nb, a, b)
    timefunc(correct, "numba (%d threads)" % nthreads, func_nb_mt, a, b)
#+END_SRC

#+BEGIN_SRC bash :results verbatim
python mt-numba-example.py 1e8
#+END_SRC

#+RESULTS:
: numpy (1 thread)     12389 ms
: numba (1 thread)      6354 ms
: numba (4 threads)     2032 ms


** Saved results

|   N | numpy 1 thread | numba 1 thread | numba 4 threads | Speedup |
|-----+----------------+----------------+-----------------+---------|
| 1e6 |          0.065 |          0.048 |           0.022 |    2.18 |
| 1e7 |          0.881 |          0.509 |           0.225 |    2.26 |
| 1e8 |         11.954 |          6.464 |           2.337 |    2.77 |
#+TBLFM: $5=$3/$4;f2

So that is a decent speedup of nearly 3 for large arrays

|   N | numpy 1 thread | numba 1 thread | numba 4 threads | Speedup |
|-----+----------------+----------------+-----------------+---------|
| 1e6 |          0.060 |          0.044 |           0.018 |    2.44 |
| 1e7 |          0.900 |          0.510 |           0.204 |    2.50 |
| 1e8 |         12.389 |          6.354 |           2.032 |    3.13 |
#+TBLFM: $5=$3/$4;f2

And that is even better, now that I am using =concurrent.futures= - yay!

*** Concurrent futures version
**** N = 1e6
#+RESULTS:
: numpy (1 thread)        60 ms
: numba (1 thread)        44 ms
: numba (4 threads)       18 ms
**** N = 1e7
#+RESULTS:
: numpy (1 thread)       900 ms
: numba (1 thread)       510 ms
: numba (4 threads)      204 ms
**** N = 1e8
#+RESULTS:
: numpy (1 thread)     12389 ms
: numba (1 thread)      6354 ms
: numba (4 threads)     2032 ms
*** Original version
**** N=1e6
#+RESULTS:
: numpy (1 thread)        65 ms
: numba (1 thread)        48 ms
: numba (4 threads)       22 ms

**** N=1e7
#+RESULTS:
: numpy (1 thread)       881 ms
: numba (1 thread)       509 ms
: numba (4 threads)      225 ms

**** N=1e8
#+RESULTS:
: numpy (1 thread)     11954 ms
: numba (1 thread)      6464 ms
: numba (4 threads)     2337 ms
